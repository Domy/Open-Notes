# JavaScript忍者秘籍

### 函数的基础知识

#### 函数是第一型对象

对象在 JavaScript 中有如下功能：

* 它们可以通过字面量进行创建。
* 它们可以赋值给变量、数组或其它对象的属性。
* 它们可以作为参数传递给函数。
* 它们可以作为函数的返回值进行返回。
* 它们可以拥有动态创建并赋值的属性。

在 JavaScript 中，函数拥有全部这些功能。也就是说可以像这门语言的其它对象一样使用。函数还有一个特殊的功能，它们可以被调用。

#### 事件轮询

浏览器的事件轮询是单线程的。每个事件都是按照在队列中所放置的顺序来处理的。在任何情况下，单线程都不能同时执行两个处理程序。

#### 回调函数

当我们定义一个函数稍后执行时，无论何时定义，在浏览器执行还是在其它地方执行，我们定义的就是所谓的回调（callback）。

### 函数声明

命名一个函数时，该名称在整个函数声明范围内是有效的。如果一个命名函数声明在顶层，window对象上的同名属性则会引用到该函数。

所有的函数都会有一个name属性，该属性保存的是该函数名称的字符串。匿名函数的name属性为空字符串。

#### 作用域和函数

* 变量声明的作用域开始于声明的地方，结束于所在函数的结尾。
* 命名函数的作用域是指声明该函数的整个函数范围（函数提升）。
* 对于作用域声明，全局上下文就像一个包含页面所有代码的大型函数。

### 函数调用

* 作为一个函数进行调用。
* 作为一个方法进行调用，在对象上进行调用。
* 作为构造器进行调用，创建一个新对象。
* 通过 ```apply()``` 或 ```call()``` 方法进行调用。

通过在表达式后面加上小括号 ```()``` 来执行函数引用。如果要给函数传递参数，则需要将参数放在小括号里并以逗号分隔。

所有的函数调用都会传递两个隐式参数：```arguments``` 和 ```this```。

#### arguments 参数

```arguments``` 参数是传递给函数的所有参数的一个集合。该集合有一个 ```length``` 属性，其值是全部参数的个数，单个参数值可以像访问数组索引一样进行获取。值得注意的是，```arguments``` 只是一个类数组的结构，只拥有数组的某些特性，但不是数组！

#### this 参数

```this``` 参数引用了与该函数调用进行隐式关联的一个对象，被称之为函数上下文（function context）。

当函数作为普通函数进行调用时，函数的上下文（this的值）是window对象。在严格模式下 ```"use strict"``` 下，函数的上下文是undefined。

当函数被赋值给对象的一个属性，并使用对象的该属性进行调用时，该对象就变成了函数的上下文，并且函数内部可以以this参数的形式进行访问。

当函数通过构造器的方式进行调用时，其上下文对象则是新创建的对象实例。

构造器的目的是通过函数调用初始化创建新的函数。将函数作为构造器（constructor）进行调用，需要使用 ```new``` 关键字。构造器的目的是要创建一个新对象并对其进行设置，然后将其作为构造器的返回值进行返回。任何干扰这种意图的函数，都不适合作为构造器。

通过使用 ```apply()``` 或 ```call()``` 方法，我们可以显式指定任何一个对象作为其函数的上下文。```apply()``` 接收两个参数：一个是作为函数上下文的对象，另一个是作为函数参数所组成的数组。```call()``` 的使用方式类似，唯一区别是给函数传入的参数是一个参数列表，而不是单个数组。

### 函数的实际应用

#### 匿名函数

#### 递归

#### 将函数视为对象

函数的 ```length``` 属性

该属性的值等于该函数声明时所需要传入的形参数量。通过其length属性，可以知道声明了多少命名参数。

通过 ```arguments.length``` 属性，可以知道在调用时传入了多少参数。

#### 函数判断

```javascript
function fun(){}
Object.prototype.toString.call(fun) === "[object Function]"
// true
```

访问 ```Object.prototype``` 的内部 ```toString()``` 方法，这个方法是用来返回表示一个对象的内部描述的字符串。通过直接访问 ```Object.prototype``` 的方法，可以确保我们得到的不是覆盖版本的 ```toString()```。